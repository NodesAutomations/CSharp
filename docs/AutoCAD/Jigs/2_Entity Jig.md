### References
- https://github.com/NodesAutomations/CSharp/issues/38
- https://spiderinnet1.typepad.com/blog/2012/03/autocad-net-entityjig-jig-line-by-start-and-end-points.html

### What is it? 
- Entity Gig provide more interactive way to get input from user rather than autocad usual getting input from editor
- Entity Jig automatically update autocad active graphics depending on user live input, make it much more visual than regular autocad commands where you can only see all changes when command is done
- but with using Entity Jig user will be able to see all changes made to drawing in real time, this can reduce number of adjustment user need to do when something is autogenerated by code

### How it work?
- Entity Jig Class is AutoCAD Inbuit Abstract Class, we have to write our own code to create jig using this class
- Entity Jig Class has 3 parts Constructor, Sampler Method and Update method
 - Constructor Basically Get entity inputs from client 
 - Sampler Method contain code to get jig input from user and return SampleStatus as output
 - Update Method update our Entity if successful results are given by user in Sampler Method

### Sample Code

```csharp
public static class Commands
{
    [CommandMethod("Test", CommandFlags.UsePickSet)]
    public static void Test()
    {
        try
        {
            var doc = Application.DocumentManager.MdiActiveDocument;
            var db = doc.Database;
            var ed = doc.Editor;

            var ppo = new PromptPointOptions("\nCenter: ");
            var ppr = ed.GetPoint(ppo);
            if (ppr.Status != PromptStatus.OK)
                return;


            using (var transaction = ActiveUtil.TransactionManager.StartTransaction())
            {
                var circle = new Circle(ppr.Value, Vector3d.ZAxis, 1.0);

                circle.TransformBy(ed.CurrentUserCoordinateSystem);
                var jig = new CircleJig(circle);
                var pr = ed.Drag(jig);
                if (pr.Status == PromptStatus.OK)
                {
                    var curSpace = (BlockTableRecord)transaction.GetObject(db.CurrentSpaceId, OpenMode.ForWrite);
                    curSpace.AppendEntity(circle);
                    transaction.AddNewlyCreatedDBObject(circle, true);
                }

                transaction.Commit();
            }
        }
        catch (System.Exception ex)
        {
            Application.ShowAlertDialog($"Something went wrong error:{ex.Message}");
        }
    }
}
class CircleJig : EntityJig
{
    Circle circle;
    double radius;
    Point3d basePoint;

    public CircleJig(Circle circle) : base(circle)
    {
        this.circle = circle;
        basePoint = circle.Center;
        radius = circle.Radius;
    }

    protected override SamplerStatus Sampler(JigPrompts prompts)
    {
        var options = new JigPromptDistanceOptions("\nRadius: ");
        options.BasePoint = basePoint;
        options.UseBasePoint = true;
        options.Cursor = CursorType.RubberBand;
        options.UserInputControls =
            UserInputControls.Accept3dCoordinates |
            UserInputControls.UseBasePointElevation;
        var result = prompts.AcquireDistance(options);
        if (result.Value == 0.0 || result.Value == radius)
            return SamplerStatus.NoChange;
        radius = result.Value;
        return SamplerStatus.OK;
    }

    protected override bool Update()
    {
        circle.Radius = radius;
        return true;
    }
}
```